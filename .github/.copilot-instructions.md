# GitHub Copilot Instructions for jest-parallel-worker

## Repository Overview

This is **jest-parallel-worker**, a Node.js SDK that extends Jest to run tests in parallel at the test level, providing significant performance improvements and detailed reporting capabilities. The project includes both CLI tools and programmatic SDK interfaces.

## Project Architecture

### Core Structure
```
src/
├── core/           # Core execution engine
│   ├── runner.js              # Main test runner orchestration
│   ├── worker-manager.js      # Worker process management & timeout handling
│   ├── parser.js              # Jest test file parsing & AST analysis
│   ├── reporter.js            # HTML/JSON report generation
│   └── execution-logger.js    # Detailed execution logging
├── workers/        # Worker process implementations
│   ├── native-parallel-worker.js    # Native Jest execution
│   ├── concurrent-file-worker.js    # File-level concurrent execution
│   ├── concurrent-test-worker.js    # Test-level concurrent execution
│   └── test-worker.js               # Individual test execution
├── config/         # Configuration management
│   └── index.js               # Configuration loading and validation
├── utils/          # Utility functions
│   └── logger.js              # Logging infrastructure
├── custom-test-runner.js      # Custom runner for true intra-file parallelism
└── index.js        # Main SDK export
```

### Key Components

1. **JestParallelRunner**: Main orchestrator that coordinates test execution
2. **WorkerManager**: Manages worker processes, timeouts, and execution modes
3. **TestParser**: AST-based parsing of Jest test files to extract test metadata
4. **ReportGenerator**: Creates detailed HTML and JSON reports with metrics
5. **Workers**: Different execution strategies (native, concurrent, individual)
6. **CustomTestRunner**: Enables true intra-file parallelism for enhanced performance

## Execution Modes

The system supports 5 execution modes:

1. **`parallel-test`**: Individual test-level parallelism (rewrites tests to concurrent)
2. **`parallel-file`**: File-level parallelism with custom worker management
3. **`jest-parallel`**: Jest's native parallel capabilities with file-level processes
4. **`native-parallel`** (Recommended): Uses Jest's native parallel capabilities with optional intra-file parallelism
5. **`custom-runner`**: Uses custom test runner for true intra-file parallelism

## Key Features & Integration Points
### Custom Test Runner
- **True Intra-file Parallelism**: Custom runner enables parallel execution of tests within the same file
- **Worker Pool Management**: Configurable concurrency level for test execution
- **Enhanced Performance**: Significant speed improvements for test-heavy files
- **Jest Compatibility**: Maintains compatibility with existing Jest test suites

### Force Concurrent Mode
- **Automatic Transformation**: Converts regular `test()` and `it()` calls to `test.concurrent()`
- **Selective Application**: Works with `parallel-file` and `jest-parallel` modes
- **Non-destructive**: Original test files remain unchanged

### Configuration Management
- **ConfigLoader**: Centralized configuration loading and validation
- **Multiple Sources**: Supports CLI arguments, config files, and environment variables
- **Schema Validation**: Ensures configuration integrity and provides helpful error messages

### Timeout Handling
- **Multi-Level Timeouts**: WorkerManager, Individual Workers, and Jest process timeouts
- **User-Specified Timeouts**: Respects `--timeout` parameter (in minutes, converted to milliseconds)
- **Jest Timeout Parameters**: Uses `--testTimeout` to constrain Jest execution time
- **Process Cleanup**: SIGTERM followed by SIGKILL for stuck processes

### Hook Support & Timing
- **Hook Duration Calculation**: Estimates beforeAll, beforeEach, afterAll, afterEach timing
- **Nested Describe Blocks**: Proper parsing of nested test suites and their hooks
- **Execution Context**: Maintains proper hook execution order and scope

## Development Guidelines for Copilot

### Code Style & Patterns

1. **Async/Await**: Prefer async/await over Promises where possible
2. **Error Handling**: Always wrap async operations in try-catch blocks
3. **Logging**: Use structured logging with context (workerId, filePath, timing)
4. **Process Management**: Always handle process cleanup and timeout scenarios

### Worker Process Patterns

When creating or modifying workers:

```javascript
// Standard worker timeout pattern
const timeoutId = setTimeout(() => {
  if (!worker.killed) {
    worker.kill('SIGKILL');
    this.executionLogger.logWorkerTimeout(workerId, `Exceeded ${this.formatDuration(this.timeout)} timeout limit`);
    this.logger.warn(`Worker ${workerId} killed due to timeout`);
  }
}, this.timeout);

worker.on('close', (code) => {
  clearTimeout(timeoutId);
  // Handle completion
});
```

### Jest Command Construction

Always include timeout constraints when spawning Jest:

```javascript
const jestArgs = [
  '--testMatch', `${workItem.filePath}`,
  '--verbose',
  '--no-coverage',
  '--runInBand',
  '--passWithNoTests=false',
  '--testTimeout', this.timeout.toString()  // Critical for timeout enforcement
];

const worker = spawn('npx', ['jest', ...jestArgs], {
  stdio: ['pipe', 'pipe', 'pipe'],
  env: { ...process.env },
  cwd: process.cwd()
});
```

### Custom Runner Integration

When using the custom test runner for true intra-file parallelism:

```javascript
// Custom runner configuration
const customRunner = new CustomTestRunner({
  concurrency: this.options.runnerConcurrency || 4,
  timeout: this.options.timeout,
  verbose: this.options.verbose
});

// Execute tests with custom runner
const results = await customRunner.runTests(testFiles, {
  onProgress: (progress) => this.logger.info(`Progress: ${progress.completed}/${progress.total}`)
});
```

### Output Parsing Patterns

Jest output parsing should handle various test result formats:

```javascript
// Multi-strategy parsing approach
const parseResult = this.parseJestOutput(combinedOutput, workItem);
const testResults = parseResult.testResults || parseResult;
const hookInfo = parseResult.hookInfo || {};

// Hook duration calculation with estimation fallback
this.calculateHookDurations(overallSuiteDuration, totalTestDuration, testResults, hookInfo, workItem);
```

### Configuration Handling

Always respect user configuration and provide sensible defaults:

```javascript
constructor(options, logger, executionLogger) {
  this.options = {
    mode: 'parallel-test',
    testMatch: 'tests/**/*.test.js',
    timeout: 30000,
    maxWorkers: 4,
    reporter: 'both',
    outputDir: './reports',
    intraFileParallelism: true,
    customRunner: false,
    runnerConcurrency: 4,
    forceConcurrent: false,
    ...options
  };
  this.timeout = options.timeout || 30000; // Default 30 seconds in milliseconds
}
```

## Integration Considerations

### Jest Compatibility
- **Version Requirements**: Supports Jest >=29.0.0
- **Configuration**: Respects existing jest.config.js files
- **Test Discovery**: Uses Jest's test matching patterns
- **Reporter Integration**: Can coexist with Jest's built-in reporters

### Custom Runner Benefits
- **True Parallelism**: Enables parallel execution of tests within the same file
- **Performance Gains**: Significant speed improvements for test-heavy files
- **Resource Management**: Configurable concurrency levels to optimize system resources

### CLI Integration
- **Commander.js**: Uses commander for CLI argument parsing
- **Configuration Files**: Supports JSON configuration files with ConfigLoader
- **Environment Variables**: Respects standard Jest environment variables

## Common Patterns & Anti-Patterns

### ✅ Good Patterns

1. **Structured Logging**:
```javascript
this.logger.debug(`Worker ${workerId} processing ${path.basename(workItem.filePath)}`);
this.executionLogger.logWorkerStart(workerId, workItem);
```

2. **Timeout Management**:
```javascript
// Always use unique timeout IDs to avoid conflicts
const testWorkerTimeoutId = setTimeout(() => { /* cleanup */ }, timeout);
clearTimeout(testWorkerTimeoutId);
```

3. **Error Classification**:
```javascript
const { errorMessage, failureType, hookType } = this.classifyJestError(errorText, suiteName);
```

### ❌ Anti-Patterns

1. **Hardcoded Timeouts**: Never use fixed timeout values, always respect user configuration
2. **Missing Cleanup**: Always clear timeouts and kill processes on completion
3. **Synchronous Operations**: Avoid blocking operations in worker coordination
4. **Silent Failures**: Always log errors and provide meaningful error messages

## Testing Patterns

When adding new features or workers:

1. **Test Different Modes**: Verify all execution modes (parallel-test, native-parallel, custom-runner)
2. **Timeout Scenarios**: Test timeout handling with short timeouts
3. **Hook Behavior**: Verify beforeAll/afterAll hooks work correctly
4. **Error Handling**: Test malformed Jest output and process failures
5. **Report Generation**: Ensure HTML and JSON reports are generated correctly
6. **Custom Runner**: Test intra-file parallelism and worker pool management

## Performance Considerations

1. **Worker Pool Management**: Balance parallelism with system resources
2. **Memory Usage**: Monitor Node.js heap usage in worker processes
3. **Process Cleanup**: Ensure worker processes terminate properly
4. **Output Buffer Management**: Handle large Jest output efficiently

## File-Specific Context

### `worker-manager.js`
- Central coordinator for all worker processes
- Handles timeout enforcement at multiple levels
- Manages execution mode routing and worker spawning
- Responsible for test status tracking and progress reporting

### `native-parallel-worker.js`
- Individual worker process implementation
- Supports Jest execution with proper timeout constraints
- Handles Jest output parsing and result formatting
- Implements timeout constraints and process cleanup

### `custom-test-runner.js`
- Enables true intra-file parallelism
- Manages worker pool for concurrent test execution
- Provides progress tracking and result aggregation
- Optimizes performance for test-heavy files

### `parser.js`
- AST-based test file analysis
- Extracts test metadata without executing code
- Identifies hooks, describe blocks, and test functions
- Provides test counting and discovery capabilities

### `reporter.js`
- Generates comprehensive HTML and JSON reports
- Includes performance metrics and visualizations
- Supports multiple output formats and customization
- Integrates with execution logging for detailed insights

### `config/index.js`
- Centralizes configuration loading and validation
- Supports multiple configuration sources (CLI, files, environment)
- Provides schema validation and error handling
- Ensures configuration consistency across components

This repository is actively developed with focus on performance, reliability, and seamless Jest integration. When contributing, prioritize backward compatibility, comprehensive error handling, and support for both traditional Jest execution and the enhanced custom runner capabilities.